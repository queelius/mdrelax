---
title: "Exponential Series Systems with Masked Data"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Exponential Series Systems with Masked Data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Introduction

The `mdrelax` package provides tools for likelihood-based inference in series
systems with masked failure data. This vignette demonstrates the basic workflow
using exponential component lifetimes.

## Setup

```{r load-packages, message=FALSE}
library(mdrelax)
```

## Simulating Masked Data

We simulate a series system with 3 components having exponential lifetimes
with rates $\lambda = (1.0, 1.5, 2.0)$.

```{r simulate-data}
set.seed(42)

# True parameters
lambda_true <- c(1.0, 1.5, 2.0)
n <- 100  # sample size
m <- 3    # number of components

# Generate component failure times
T_mat <- matrix(rexp(n * m, rate = rep(lambda_true, each = n)),
                nrow = n, ncol = m)

# System failure time is minimum of component times
t_sys <- apply(T_mat, 1, min)

# Identify which component failed (latent)
k_failed <- apply(T_mat, 1, which.min)

# Create data frame with component times
md <- data.frame(
  t = t_sys,
  t1 = T_mat[, 1],
  t2 = T_mat[, 2],
  t3 = T_mat[, 3],
  delta = rep(1, n)  # all observed (no censoring): delta=1 means failure observed
)
```

## Applying Bernoulli Masking (C1-C2-C3)

Under the standard C1-C2-C3 conditions, we apply Bernoulli masking where
each non-failed component is included in the candidate set with probability $p$.

```{r apply-masking}
# Apply Bernoulli masking with p = 0.3
md <- md_bernoulli_cand_C1_C2_C3(md, p = 0.3)

# Sample candidate sets
md <- md_cand_sampler(md)

# View first few rows
head(md[, c("t", "x1", "x2", "x3")])
```

The columns `x1`, `x2`, `x3` indicate which components are in each candidate set
(1 = in candidate set, 0 = not in candidate set).

## Maximum Likelihood Estimation

We compute the MLE for the component rate parameters:

```{r mle}
fit <- md_mle_exp_series_C1_C2_C3(md)
print(fit)
```

## Comparing to True Values

```{r compare}
# Extract point estimates using algebraic.mle accessor
estimates <- algebraic.mle::params(fit)

# Compare to true values
comparison <- data.frame(
  Component = paste0("lambda_", 1:m),
  True = lambda_true,
  Estimate = estimates,
  Bias = estimates - lambda_true
)
print(comparison)
```

## Fisher Information Matrix

The Fisher Information Matrix provides information about estimation precision:

```{r fim}
# Create FIM function and evaluate at MLE
fim_fn <- md_fim_exp_series_C1_C2_C3(md)
fim <- fim_fn(estimates)
print(fim)

# Standard errors from inverse FIM
se <- sqrt(diag(solve(fim)))
cat("\nStandard errors:", round(se, 4), "\n")
```

## Summary

This vignette demonstrated:

1. Simulating exponential series system data
2. Applying Bernoulli masking under C1-C2-C3 conditions
3. Computing the MLE for component rate parameters
4. Evaluating estimation precision via the Fisher Information Matrix

For more advanced usage including informative masking models and relaxed
conditions, see the package documentation.
