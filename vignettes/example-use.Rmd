---
title: "Exponential Series Systems with Masked Data"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Exponential Series Systems with Masked Data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Introduction

The `mdrelax` package provides tools for likelihood-based inference in series
systems with masked failure data. This vignette demonstrates the basic workflow
using exponential component lifetimes under the standard C1-C2-C3 conditions
and the relaxed C2 (informative masking) model.

## Setup

```{r load-packages, message=FALSE}
library(mdrelax)
```

## Simulating Masked Data (C1-C2-C3)

We simulate a series system with 3 components having exponential lifetimes
with rates $\lambda = (1.0, 1.5, 2.0)$.

```{r simulate-data}
set.seed(42)
lambda_true <- c(1.0, 1.5, 2.0)

# Generate masked data: n=200 observations, masking probability p=0.3,
# right-censoring at tau=5
sim <- rexp_series_md(n = 200, theta = lambda_true, p = 0.3, tau = 5)

# sim contains: t (system times), delta (censoring), C (candidate sets), k (true cause)
cat("Sample size:", length(sim$t), "\n")
cat("Uncensored:", sum(sim$delta), "\n")
cat("Components:", ncol(sim$C), "\n")
```

The candidate set matrix `C` is logical: `C[i,j] = TRUE` means component $j$
is in observation $i$'s candidate set.

## Maximum Likelihood Estimation

```{r mle}
fit <- mle_exp_series(sim$t, sim$C, sim$delta)

cat("Converged:", fit$converged, "\n")
cat("Estimates:", round(fit$theta, 3), "\n")
cat("Std errors:", round(fit$se, 3), "\n")
cat("Log-likelihood:", round(fit$loglik, 2), "\n")
```

## Comparing to True Values

```{r compare}
comparison <- data.frame(
  Component = paste0("lambda_", seq_along(lambda_true)),
  True = lambda_true,
  Estimate = round(fit$theta, 3),
  SE = round(fit$se, 3),
  Bias = round(fit$theta - lambda_true, 3)
)
print(comparison)
```

## Fisher Information and Score

The analytical score and Fisher information functions can be evaluated at any
parameter value:

```{r score-fim}
# Create score and FIM functions from the same data
sc_fn <- score_exp_series(sim$t, sim$C, sim$delta)
fim_fn <- fim_exp_series(sim$t, sim$C, sim$delta)

# Score should be near zero at the MLE
cat("Score at MLE:", round(sc_fn(fit$theta), 4), "\n")

# FIM at MLE
fim <- fim_fn(fit$theta)
cat("\nFisher Information Matrix:\n")
print(round(fim, 3))
```

## Data Frame Interface

For interoperability, data can be converted to data frames:

```{r dataframe}
df <- as_dataframe(sim)
head(df[, 1:5])

# All functions have _df variants
fit_df <- mle_exp_series_df(df)
cat("Same estimates:", all.equal(fit$theta, fit_df$theta), "\n")
```

## Relaxed C2: Informative Masking

When the masking probability depends on which component failed, we use the
relaxed C2 model with a P matrix: `P[j,k] = P(j in C | K = k)`.

```{r relaxed-c2}
# Create an asymmetric P matrix (violates C2)
P <- matrix(c(1.0, 0.2, 0.4,
              0.5, 1.0, 0.3,
              0.3, 0.6, 1.0), nrow = 3, byrow = TRUE)

# Generate data under this informative masking
sim_r <- rexp_series_md_c1_c3(n = 200, theta = lambda_true, P = P, tau = 5)

# Fit with the correct model (known P)
fit_r <- mle_exp_series_c1_c3(sim_r$t, sim_r$C, sim_r$delta, fixed_P = P)

cat("Relaxed C2 estimates:", round(fit_r$theta, 3), "\n")
cat("Converged:", fit_r$converged, "\n")
```

## Summary

This vignette demonstrated:

1. Simulating masked data with `rexp_series_md()`
2. Computing the MLE with `mle_exp_series()`
3. Evaluating score and FIM at arbitrary parameter values
4. Using the data frame interface
5. Informative masking with the relaxed C2 model

For Weibull component lifetimes, see `mle_wei_series()`. For simulation
studies comparing model robustness, see `quick_simulation_study()`.
